<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: opiniao | Nome do Jogo]]></title>
  <link href="http://nomedojogo.com/categories/opiniao/atom.xml" rel="self"/>
  <link href="http://nomedojogo.com/"/>
  <updated>2011-10-18T20:54:12-02:00</updated>
  <id>http://nomedojogo.com/</id>
  <author>
    <name><![CDATA[Carlos Brando]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Contratos onde todos ganham]]></title>
    <link href="http://nomedojogo.com/2011/09/12/contratos-onde-todos-ganham/"/>
    <updated>2011-09-12T11:09:00-03:00</updated>
    <id>http://nomedojogo.com/2011/09/12/contratos-onde-todos-ganham</id>
    <content type="html"><![CDATA[<p>Lidar com computadores não é fácil, por outro lado lidar com pessoas costuma ser ainda mais complicado. A muito tempo eu já me convenci que o relacionamento entre clientes e programadores sempre serão problemáticos.</p>

<p>A forma mais simples de tentar diminuir a tensão entre os lados envolvidos são os contratos.</p>

<p>Um bom contrato deve deixar claro quais são os direitos e responsabilidades de cada um dos envolvidos. Também não deve deixar dúvidas sobre qual será a repercussão no caso de uma das partes não cumprir com o acordo.</p>

<p>Um tipo básico de contrato é o que define um preço fixo para o projeto. Esse tipo de contrato é a melhor opção para o cliente e a pior para o programador. Uma mudança no escopo ou um pequeno atraso e tudo vai para a conta do desenvolvedor, deixando todo o risco nas mãos do profissional. Normalmente esse é o tipo de contrato que mais dá problema, já que o programador costuma se sentir lesado por alterações no escopo do projeto e o cliente não se sente na obrigação de pagar mais por isso.</p>

<p>Por outro lado um contrato de tempo e recurso, onde o cliente paga pelo tempo de cada profissional alocado no projeto é o melhor contrato para o programador, mas é o pior para o cliente. Nesse caso, atrasos e alterações no escopo caem sempre na conta do cliente, mesmo quando a culpa não é dele.</p>

<p>Para beneficiar ambos os lados, talvez o mais interessante seja unir esses dois tipos de contratos em um contrato híbrido, onde o cliente e o programador definem um valor fixo menor e uma taxa por horas de trabalho.</p>

<p>Funciona mais ou menos assim: se você estimar que serão necessárias aproximadamente duas semanas (80 horas) para finalizar o projeto e normalmente você cobra R$ 100,00 por hora, então o custo estimado para o projeto seria de R$ 8.000. Nesse tipo de contrato você definiria então com o cliente um pagamento fixo no valor de R$ 4.000 e mais uma taxa de R$ 50,00 reais por hora trabalhada no projeto.</p>

<p>Se o projeto terminar dentro do prazo, o cliente terá pago exatamente o valor estimado para o projeto e todos ganham.</p>

<p>Se o projeto terminar antes da data, o cliente terá pago menos e você terá ganho mais. Digamos que o projeto seja finalizado com 60 horas trabalhadas. Então o cliente pagará R$ 7.000 pelo serviço, que é menos do que o esperado. E você receberá R$ 1.000 a mais do que você receberia pelas 60 horas trabalhadas. Mais uma vez, todos ganham.</p>

<p>Por outro lado, se algo acontecer e o projeto atrasar, então o cliente estará pagando adicionalmente metade da sua hora, dividindo assim igualmente o risco entre o cliente e o programador.</p>

<p>Não importa se você usa uma metodologia ágil ou um modelo mais tradicional, contratos são essenciais em qualquer negocio e não será diferente em desenvolvimento de software. O importante é que você nunca feche um negócio sem assinar um antes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Como convencer sua equipe a usar um sistema de controle de versão]]></title>
    <link href="http://nomedojogo.com/2011/08/25/como-convencer-sua-equipe-a-usar-um-sistema-de-controle-de-vers-o/"/>
    <updated>2011-08-25T02:02:00-03:00</updated>
    <id>http://nomedojogo.com/2011/08/25/como-convencer-sua-equipe-a-usar-um-sistema-de-controle-de-vers-o</id>
    <content type="html"><![CDATA[<p>Desenvolver software sem um sistema de controle de versão (ou SCM do inglês source code management) pode parecer irreal para muitos dos leitores desse blog, mas é importante esclarecer que muitas empresas e profissionais ainda não entendem o valor desse tipo de ferramenta.</p>

<blockquote><p>Nota para o leitor: Se você não sabe o que é um SCM, recomendo ouvir a série sobre o assunto que gravamos recentemente para o <a href="http://grokpodcast.com/tag/scm/">Grok Podcast</a>.</p></blockquote>

<p>A situação fica ainda mais dramática quando um programador "iniciante", porém esclarecido, trabalha em uma empresa que ainda armazena o código-fonte de seus projetos em um diretório no servidor ou somente no computador do desenvolvedor. Nesse caso, como convencer seus colegas de trabalho e principalmente o seu chefe que eles precisam adotar uma ferramenta para controlar o código?</p>

<p>A palavra-chave aqui é <strong>evangelização</strong>. Comece implementando o seu próprio SCM particular. Existem dezenas de opções open-source que podem ser instaladas localmente em sua máquina ou em um servidor da empresa que você tenha acesso. Essa iniciativa fará com que ao menos o seu código tenha uma certa medida de segurança, o que lhe trará um pouco de tranquilidade.</p>

<p>Com o tempo você, diferente de seus colegas, passará a ter a resposta para perguntas como: "Exatamente que alteração foi realizada no módulo XYZ?" e "Quem foi o responsável pela alteração que quebrou o software?". É questão de tempo até que seu chefe e colegas se convençam das vantagens em adotar um sistema para gerenciar o código da sua empresa.</p>

<p>Ainda outra opção é fazer com que sua equipe ouça o <a href="http://grokpodcast.com/">Grok Podcast</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quatro anos de Nome do Jogo]]></title>
    <link href="http://nomedojogo.com/2011/02/08/quatro-anos-de-nome-do-jogo/"/>
    <updated>2011-02-08T00:00:00-02:00</updated>
    <id>http://nomedojogo.com/2011/02/08/quatro-anos-de-nome-do-jogo</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://old.nomedojogo.com/wp-content/uploads/2011/02/247607315_a74fac5aa4.jpg" width="500" height="332"></p>

<p>Hoje completam quatro anos desde que comecei a escrever esse blog. No total são 812 artigos e 4.305 comentários. Sempre mantive um ritmo muito bom de publicação, porém com o crescimento do Twitter (<a href="http://twitter.com/#!/carlosbrando">@carlosbrando</a>) como ferramenta de comunicação o tempo entre um artigo e outro diminuiu muito, eu tenho de confessar.</p>

<p>Escrever e manter um blog por tanto tempo não é fácil, principalmente se você tem a intenção de publicar conteúdo de qualidade. Mas as recompensas valem muito a pena, nesses quatro anos esse blog gerou dois livros, muitos vídeos, um podcast semanal sobre <a href="http://podcast.rubyonrails.pro.br/">Ruby on Rails</a> e agora o <a href="http://grokpodcast.com/">Grok Podcast</a>. Sem contar todas as outras oportunidades que apareceram graças a essa iniciativa.</p>

<p>Obrigado pela audiência!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["Eu quebrei o código"]]></title>
    <link href="http://nomedojogo.com/2010/07/01/eu-quebrei-o-codigo/"/>
    <updated>2010-07-01T00:00:00-03:00</updated>
    <id>http://nomedojogo.com/2010/07/01/eu-quebrei-o-codigo</id>
    <content type="html"><![CDATA[<p>No dia 9 de setembro de 1945 a equipe da Dr. Grace Hopper (que mais tarde se tornaria a criadora da linguagem COBOL) e de Howard H. Aiken estava diante de um problema na sala do computador Mark II.  Depois de uma análise minuciosa detectaram uma mariposa entre os contatos de um dos relés do computador. Ironicamente Grace documentou o incidente nos registros adicionando o inseto e a frase "First atual case of bug being found".</p>

<p><img class="center" src="http://old.nomedojogo.com/wp-content/uploads/2010/07/H96566k.jpg"></p>

<p>Existe um efeito psicologico muito forte quando um erro explode em um software. É dificil para um profissional assumir que cometeu um erro ou deixou de testar adequadamente antes de colocar algo em produção. Quando um bug aparece, a tendencia é sempre procurar pelo culpado ao invés de procurar pelo problema.</p>

<p>Há alguns anos eu trabalhei em uma consultoria que mantinha uma lista na parede com um ranking dos programadores que mais deixavam bugs no código. Toda vez que um usuário ligava reclamando de algo, iniciava-se uma espécie de corrida para ver quem encontrava o culpado primeiro. Assim que o infeliz programador era apontado, ele era obrigado a vestir uma faixa com os dizeres: <strong>"Eu quebrei o código"</strong> durante todo o dia de trabalho.</p>

<p><img class="center" src="http://old.nomedojogo.com/wp-content/uploads/2010/07/g2Ofy.jpg"></p>

<p>Não é possível desenvolver um software isento de falhas. Infelizmente, os computadores ainda estão limitados a fazer aquilo que <em>mandamos</em> ele fazer, e não necessariamente aquilo que <em>queremos</em> que ele faça. E enquanto isso não se tornar uma realidade estaremos sempre em <a href="http://www.nomedojogo.com/2009/03/12/um-pouco-mais-sobre-%E2%80%9Cdon%E2%80%99t-repeat-yourself%E2%80%9D/">modo de manutenção</a>.</p>

<p>Desenvolver é um ciclo que envolve escrever algo original por alguns minutos e então passar algumas horas solucionando bugs. Escrever um código novo e então reescrever algo que aparentemente ficou ruim. Todos os programadores deveriam ter isso em mente antes de ingressarem nessa profissão.</p>

<p>Um bom programador precisa inicialmente desligar todos esses sistemas instintivos de defesa. Eu sei muito bem o que é estar procurando por um bug no código com o gerente de um lado e o cliente do outro observando cada passo que você dá. Concentre-se, não perca o foco.</p>

<p>Pense em um médico. O paciente chega no consultório com dor de cabeça, nauseas, dor em certas partes do corpo, etc.. Se o médico tentar solucionar cada um dos sintomas de forma isolada ele estará mascarando o real problema do paciente. O objetivo é identificar o que está gerando todos esses sintomas. Ao localizar a raiz do problema e medicar o paciente corretamente, de forma natural todos os sintomas desaparecerão.</p>

<p>Da mesma forma, o maior erro que um programador pode cometer ao tentar resolver uma falha em um sistema é atacar os sintomas. Isso normalmente só confundirá a sua mente.</p>

<p>A maneira mais simples de encontrar um erro no código é explicando o problema para outro programador. A outra pessoa não precisa dizer uma única palavra, o simples fato de explicar passo-a-passo o que o código deveria fazer, normalmente é o suficiente para que você mesmo vislumbre o que pode estar causando a falha.</p>

<p>Pode parecer simples demais, mas ao explicar o problema para outra pessoa você terá de entrar em detalhes que talvez estejam passando despercebidos por você. Isso lhe dará uma nova visão do problema.</p>

<p>Solucionar bugs é parte da rotina de um programador. Algumas técnicas apenas diminuem a quantidade de incidencias no seu código, mas evitá-los totalmente é impossível. O mais importante é ter em mente que um erro no software, mesmo trabalhando em uma grande equipe nunca terá um culpado, ele sempre será um problema seu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programadores: Nem sempre o time que está ganhando está ganhando]]></title>
    <link href="http://nomedojogo.com/2010/06/04/programadores-nem-sempre-o-time-que-esta-ganhando-esta-ganhando/"/>
    <updated>2010-06-04T00:00:00-03:00</updated>
    <id>http://nomedojogo.com/2010/06/04/programadores-nem-sempre-o-time-que-esta-ganhando-esta-ganhando</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://old.nomedojogo.com/wp-content/uploads/2010/06/2628233713_80b72163f4.jpg"></p>

<p>Estou sempre recebendo e-mails de pessoas interessadas em Ruby me questionando se realmente vale a pena gastar o seu tempo estudando essa linguagem de programação ao invés de estudar linguagens mais conhecidas como Java ou C#. Tenho certeza que a mesma dúvida preenche a mente de qualquer um que esteja interessado em apostar em alguma tecnologia emergente.</p>

<p>Por que alguém estaria disposto a gastar o seu precioso tempo estudando algo no qual não tem certeza se terá a oportunidade de ganhar dinheiro com isso depois?</p>

<p>A minha resposta sempre foi: "paixão". Bons programadores são apaixonados pelo que fazem, isso explica o motivo deles adorarem estar sempre aprendendo coisas novas.</p>

<p>Mas existe um dilema cultural aqui. A maioria de nós vem de famílias que emergiram para a classe média apenas uma ou duas gerações atrás. Fomos ensinados por nossos pais e avós a colocar os interesses financeiros da família em primeiro lugar e deixar a satisfação profissional em segundo plano. Isso explica muito bem porque tantos profissionais continuam em empregos ruins, mesmo insatisfeitos.</p>

<p>Seguindo o pensamento de nossos pais, não é mais inteligente apostar no time que está ganhando? De forma alguma. <a href="http://www.nomedojogo.com/2010/04/23/investir-em-ruby-era-muito-arriscado/">Correr riscos</a> e estar satisfeito profissionalmente são sem dúvida a receita para o sucesso.</p>
]]></content>
  </entry>
  
</feed>
